\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large  \bf  #1} 
{\scriptsize \lstinputlisting[language=C++]{../#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,2 по курсу:\\ Дискретный анализ}

Выполнила студентка группы М8О-407Б-17 МАИ \,\, \textit{Алексюнина Юлия}.

\subsection*{Задача}
\begin{itemize}
\item {\bf Постановка задачи:}\subitem 
Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до $2^{64} - $1. Разным словам может быть поставлен в соответствие один и тот же номер.
\\
\item {\bf Вариант дерева: }\subitem  AVL-дерево

\item{ \bf Вариант ключа:} \subitem Регистронезависимая последовательность букв английского алфавита длиной не более 256 символов.


\item {\bf Вариант значения:} \subitem   Числа от $0$ до $2^{64} − 1$.

\end{itemize}

\subsection*{Информация}

АВЛ-дерево — сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

АВЛ-дерево с n ключами имеет высоту h=O(log N).

\subsection*{Метод решения}

Данное дерево было решено реализовывать на основе двух структур TAvl и TAvlNode.

В	структуре дерева хранится только указатель на корень дерева. Структура узла содержит:
\begin{itemize}
    \item Ключ
    \item Значение
    \item Высоту узла
    \item Указатель на левого сына
    \item Указатель на правого сына
\end{itemize}

Балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев |h(L) - h(R)| = 2, изменяет связи предок-потомок в под-дереве данной вершины так, чтобы восстановилось свойство дерева |h(L) - h(R)| \leqslant 1, иначе ничего не меняет. Есть 4 типа вращений для балансировки:

\begin{itemize}
    \item Малое левое вращение
    \item Малое правое вращение
    \item Большое левое вращение
    \item Большое правое вращение
\end{itemize}
\subsubsection*{Вставка}

Пусть нам надо добавить ключ t. Будем спускаться по дереву, как при поиске ключа t. Если мы стоим в вершине a и нам надо идти в поддерево, которого нет, то делаем ключ t листом, а вершину a его корнем. Дальше поднимаемся вверх по пути поиска и пересчитываем баланс у вершин. Если мы поднялись в вершину i из левого поддерева, то dif f[i] увеличивается на единицу, если из правого, то уменьшается на единицу. Если пришли в вершину и её баланс стал равным 2 или -2, то делаем одно из четырёх вращений.

Так как в процессе добавления вершины мы рассматриваем не более, чем O(h) вершин дерева, и для каждой запускаем балансировку не более одного раза, то суммарное количество операций при включении новой вершины в дерево составляет O(log n) операций.


\subsubsection*{Удаление}

Для простоты опишем рекурсивный алгоритм удаления. Если вершина лист, то удалим её, иначе найдём самую близкую по значению вершину a, переместим её на место удаляемой вершины и удалим вершину a. От удалённой вершины будем подниматься вверх к корню и пересчитывать баланс у вершин. Если мы поднялись в вершину i из левого поддерева, то dif f[i] уменьшается на единицу, если из правого, то увеличивается на единицу.Если баланс стал равным 2 или 2, следует выполнить одно из четырёх вращений.

В результате указанных действий на удаление вершины и балансировку суммарно тратится, как и ранее, O(h) операций. Требуемое количество действий O(log n).
Также был реализован тип TString для удобной работы с ключами.

\subsection*{Генератор тестов}
Сначала создаются тесты для создания базы данных и выгрузки её на жесткий диск, потом создаются тесты на выгрузку этих баз данных и поиск в них элементов. tests.py - создание баз данных; SearchTests.py - поиск элементов в базах данных. \\\\
tests.py\\
\begin{lstlisting}[language=python]
import random

for i in range(1000, 11000, 1000):
    file = open('tests/test'+str(i)+'.txt','w')
    for k in range(1, i + 1):
        file.write('+ ')
        for j in range(1, random.randint(2,100)):
            file.write(str(chr(random.randint(97, 122))))
        file.write(' ' + str(random.randint(1,1000000)))
        file.write('\n')
    file.write("! Save tests/database" + str(i) + ".txt")
    file.close()
\end{lstlisting}

SearchTests.py\\
\begin{lstlisting}[language=python]
import random

for i in range(1000, 11000, 1000):
    file = open('tests/test'+str(i)+'.txt','w')
    file.write("! Load tests/database" + str(i) + ".txt")
    for k in range(1, i + 1):
        for j in range(1, random.randint(2,100)):
            file.write(str(chr(random.randint(97, 122))))
        file.write('\n')
    file.close()
\end{lstlisting}
\\\\
\subsection*{Тест производительности}
 
\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество элементов, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 10000, 0.16 )
        ( 9000, 0.13 )
        ( 8000, 0.12 )
        ( 7000, 0.11 )
        ( 6000, 0.09 )
        ( 5000, 0.07 )
        ( 4000, 0.06 )
        ( 3000, 0.04 )
        ( 2000, 0.03 )
        ( 1000, 0.06  )};
    \end{axis}
\end{tikzpicture}
\\ \\
\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Запросов поиска, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 10000, 0.06 )
        ( 9000, 0.05 )
        ( 8000, 0.05 )
        ( 7000, 0.04 )
        ( 6000, 0.04 )
        ( 5000, 0.03 )
        ( 4000, 0.02 )
        ( 3000, 0.02 )
        ( 2000, 0.01 )
        ( 1000, 0.06  )};
    \end{axis}
\end{tikzpicture}
\\
\subsection*{Выводы}

В данной лабораторной работе была реализована структура данных словарь, внутри которой скрыто AVL-дерево. Сложность вставки, поиска и удаления O(log(n)). Стоит использовать словарь, внутри которого AVL-дерево, если мы гарантированно хотим получить сложность O(log(n)) и данной скорости достаточно для поставленной задачи. На мой взгляд, структура данных AVL-дерево применяется редко, так как есть такая структура данных, как хэш-таблица, где те же операции работают в среднем за O(1), хотя в худшем случпе может работать за O(n), но это случается редко.

\end{document}
